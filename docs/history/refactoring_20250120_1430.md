# Refactoring Plan: Enhance Tool Response for AI Agent Context

**Date**: 2025-01-20 14:30  
**Author**: System Analysis  
**Status**: Planning

---

## Purpose

Improve MCP tool handler responses to provide clear, actionable guidance for AI agents. Current responses return only raw JSON data, lacking context about:

- What was accomplished
- What the AI should do next
- Required parameters for next actions
- Current position in the game workflow

---

## Current State / Problems

### Issue 1: Insufficient Context in Responses

**Current Implementation:**

```typescript
private async handleCreateGame(params: CreateGameParams): Promise<CallToolResult> {
  const result = this.gameManager.createGame(params.initialStateInJson);
  return {
    content: [{
      type: 'text',
      text: JSON.stringify(result, null, 2),
    }],
  };
}
```

**Problems:**

- Raw JSON only, no narrative context
- AI must infer next steps from data
- No explicit guidance on workflow progression
- Missing key information needed for decision-making

### Issue 2: Game Flow Not Explicit

**Expected Flow (from README.md):**

```
createGame ‚Üí progressStory ‚Üí promptUserActions ‚Üí selectAction ‚Üí updateGame ‚Üí progressStory ‚Üí ...
```

**Current State:**

- GameManager returns `nextActions` array, but not utilized in response text
- AI agent receives no explicit instruction about which tool to call next
- Workflow position is implicit, not stated

### Issue 3: Language Consistency

**Location**: `src/gameManager.ts` - Delta generation functions

**Current Issues:**

```typescript
// Lines 345-365: Korean text in delta descriptions
return `${friendlyFieldName}Ïóê ${finalLength - initialLength}Í∞ú Ìï≠Î™©Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§`;
return `${friendlyFieldName}Ïù¥(Í∞Ä) ${change} Ï¶ùÍ∞ÄÌñàÏäµÎãàÎã§`;

// Lines 368-381: Korean field name mappings
const fieldMap: Record<string, string> = {
  'characters': 'Ï∫êÎ¶≠ÌÑ∞',
  'world': 'ÏÑ∏Í≥Ñ',
  // ... more Korean mappings
};
```

**Problem:** Inconsistent with English-based MCP protocol and AI agent prompts

---

## Additional Analysis Tasks

### Task 1: Determine Optimal Response Format

**Question:** Should responses be Markdown-narrative or structured JSON?

**Analysis Required:**

- Compare AI agent comprehension of both formats
- Measure token efficiency
- Evaluate ease of parameter extraction

**Recommendation:** Use **human-readable Markdown format** with embedded structured data

- Pros: Clear guidance, easier for AI to understand intent
- Cons: None if all required data is included in text
- Key: Always include `gameId` and required params in response text

### Task 2: Identify Critical Information Per Tool

**For each tool handler, determine:**

- What context is essential vs. optional
- Which game state fields are most relevant
- What parameters are needed for next action
- How to represent workflow position

**Example - createGame needs:**

- ‚úÖ Generated gameId (critical)
- ‚úÖ Game title (context)
- ‚úÖ Next tool: progressStory (action)
- ‚úÖ Sample progress parameter (guidance)
- ‚ö†Ô∏è Full character list (optional, can be verbose)

### Task 3: Delta Information Presentation

**Question:** How should pending deltas be communicated?

**Current State:**

- Deltas stored in `game.state._pendingDeltas`
- Displayed in UI when `promptUserActions` is called
- Currently in Korean

**Required Analysis:**

- Translation to English
- Format for AI consumption (bullet list? table?)
- When to show deltas in response (always? only when non-empty?)

---

## Target State / Success Criteria

### Success Criterion 1: Self-Contained Responses

Each tool response must contain ALL information needed for next action:

**Example Response Structure:**

```
‚úÖ [Tool Name] Completed Successfully

üìã Game Context:
- Game ID: {gameId}
- Title: {title}
- Key State: {relevant state summary}

üìù What Happened:
{Clear description of what this tool did}

üéØ Next Step:
Call the '{nextTool}' tool with these parameters:
- gameId: "{gameId}"
- {otherParam}: {value or guidance}

Reason: {Why this is the next step}

üí° Workflow: Step X/5
{Visual workflow indicator showing current position}

üìä Full State Reference:
{Minimal essential game state - not full JSON dump}
```

### Success Criterion 2: Explicit Workflow Guidance

Each response includes:

- ‚úÖ Current workflow position (e.g., "Step 2/5")
- ‚úÖ Next tool to call by name
- ‚úÖ Reason for calling that tool
- ‚úÖ Required parameters with actual values (gameId, etc.)
- ‚úÖ Optional parameters with guidance

### Success Criterion 3: English Throughout

All text must be in English:

- ‚úÖ Delta descriptions
- ‚úÖ Field names
- ‚úÖ Success/error messages
- ‚úÖ Workflow guidance

### Success Criterion 4: Context-Aware Responses

- `getGame` analyzes state and suggests appropriate next action
- `selectAction` provides guidance on which fields to update
- `updateGame` indicates whether more updates needed or should progress story
- `promptUserActions` clearly states it's waiting for user input

---

## Code Modifications Required

### 1. Create Response Formatter Helper (NEW)

**File**: `src/index.ts`
**Location**: Add as private method in `RPGMCPServer` class

```typescript
/**
 * Format a human-readable response for AI agent
 */
private formatToolResponse(
  toolName: string,
  status: 'success' | 'error',
  summary: string,
  gameContext: {
    gameId: string;
    title?: string;
    keyState?: string[];
  },
  actionTaken: string,
  nextStep: {
    tool: string;
    reason: string;
    params: Record<string, any>;
  } | null,
  workflowPosition: string,
  additionalNotes?: string[]
): string {
  const statusEmoji = status === 'success' ? '‚úÖ' : '‚ùå';
  
  let response = `${statusEmoji} ${toolName} ${status === 'success' ? 'Completed Successfully' : 'Failed'}\n\n`;
  
  response += `üìã Game Context:\n`;
  response += `- Game ID: ${gameContext.gameId}\n`;
  if (gameContext.title) response += `- Title: ${gameContext.title}\n`;
  if (gameContext.keyState) {
    gameContext.keyState.forEach(state => response += `- ${state}\n`);
  }
  response += `\n`;
  
  response += `üìù What Happened:\n${actionTaken}\n\n`;
  
  if (nextStep) {
    response += `üéØ Next Step:\n`;
    response += `Call the '${nextStep.tool}' tool with these parameters:\n`;
    Object.entries(nextStep.params).forEach(([key, value]) => {
      response += `- ${key}: ${JSON.stringify(value)}\n`;
    });
    response += `\nReason: ${nextStep.reason}\n\n`;
  } else {
    response += `‚è∏Ô∏è Status:\nWaiting for user input. No action required until player makes a selection.\n\n`;
  }
  
  response += `üí° Workflow: ${workflowPosition}\n`;
  
  if (additionalNotes && additionalNotes.length > 0) {
    response += `\nüìå Additional Notes:\n`;
    additionalNotes.forEach(note => response += `- ${note}\n`);
  }
  
  return response;
}
```

### 2. Modify handleCreateGame

**File**: `src/index.ts`
**Lines**: 242-255 (current implementation)

**Change**: Replace JSON-only response with formatted response

```typescript
private async handleCreateGame(params: CreateGameParams): Promise<CallToolResult> {
  if (!params.initialStateInJson) {
    throw new Error('initialStateInJson parameter is required');
  }
  const result = this.gameManager.createGame(params.initialStateInJson);
  
  const responseText = this.formatToolResponse(
    'createGame',
    'success',
    `New game created with ID: ${result.game.gameId}`,
    {
      gameId: result.game.gameId,
      title: result.game.state.title,
      keyState: [
        `Characters: ${result.game.state.characters?.length || 0}`,
        `Location: ${result.game.state.world?.location || 'Unknown'}`,
        `Created: ${result.game.createdAt.toISOString()}`
      ]
    },
    `Initialized game world with provided state including characters, world settings, and inventory.`,
    {
      tool: 'progressStory',
      reason: 'Begin the narrative by describing the opening scene and establishing story context',
      params: {
        gameId: result.game.gameId,
        progress: 'Describe the opening situation, setting, and initial scenario for the player'
      }
    },
    'Step 1/5: [createGame] ‚Üí progressStory ‚Üí promptUserActions ‚Üí selectAction ‚Üí updateGame'
  );
  
  return {
    content: [{ type: 'text', text: responseText }],
  };
}
```

### 3. Modify handleUpdateGame

**File**: `src/index.ts`
**Lines**: 257-270

**Key Changes:**

- Extract and display delta information
- Provide context-aware next step (may vary based on game state)
- Show what changed and its impact

```typescript
private async handleUpdateGame(params: UpdateGameParams): Promise<CallToolResult> {
  if (!params.gameId || !params.fieldSelector || params.value === undefined) {
    throw new Error('gameId, fieldSelector, and value parameters are required');
  }
  const result = this.gameManager.updateGame(params.gameId, params.fieldSelector, params.value);
  
  const deltas = result.game.state._pendingDeltas || [];
  const deltaDescriptions = deltas.map(d => d.description).join('; ');
  
  const responseText = this.formatToolResponse(
    'updateGame',
    'success',
    `Updated ${params.fieldSelector} to ${JSON.stringify(params.value)}`,
    {
      gameId: params.gameId,
      title: result.game.state.title,
      keyState: [
        `Updated field: ${params.fieldSelector}`,
        `New value: ${JSON.stringify(params.value)}`,
        `Pending changes: ${deltas.length}`
      ]
    },
    `Game state modified. Changes: ${deltaDescriptions || 'State updated'}`,
    {
      tool: 'progressStory',
      reason: 'Narrate the consequences and outcomes of this state change in the story',
      params: {
        gameId: params.gameId,
        progress: `Describe how the change to ${params.fieldSelector} affects the game world, characters, and situation`
      }
    },
    'Step 5/5: createGame ‚Üí progressStory ‚Üí promptUserActions ‚Üí selectAction ‚Üí updateGame ‚Üí [progressStory]',
    [
      'You may call updateGame multiple times to apply multiple changes',
      'Call progressStory after all updates to narrate the cumulative results',
      `${deltas.length} change(s) will be displayed to player on next promptUserActions`
    ]
  );
  
  return {
    content: [{ type: 'text', text: responseText }],
  };
}
```

### 4. Modify handleGetGame

**File**: `src/index.ts`
**Lines**: 272-285

**Key Feature:** Analyze game state to suggest appropriate next action

```typescript
private async handleGetGame(params: GetGameParams): Promise<CallToolResult> {
  if (!params.gameId) {
    throw new Error('gameId parameter is required');
  }
  const result = this.gameManager.getGame(params.gameId);
  
  // Analyze state to determine next action
  const hasStory = !!result.game.state.lastStoryProgress;
  const hasOptions = !!result.game.state._currentOptions;
  const hasSelection = !!result.game.state.selectedAction;
  
  let nextStep = null;
  if (hasOptions && !hasSelection) {
    // Waiting for player selection
    nextStep = null;
  } else if (hasSelection) {
    nextStep = {
      tool: 'updateGame',
      reason: `Apply consequences of selected action: "${result.game.state.selectedAction?.option}"`,
      params: {
        gameId: params.gameId,
        fieldSelector: 'Determine which field to update based on the selected action',
        value: 'Calculate new value based on action outcome'
      }
    };
  } else if (hasStory) {
    nextStep = {
      tool: 'promptUserActions',
      reason: 'Present choices to player based on current story state',
      params: {
        gameId: params.gameId,
        options: ['Create 2-4 meaningful choices based on current situation']
      }
    };
  } else {
    nextStep = {
      tool: 'progressStory',
      reason: 'Begin or advance the narrative',
      params: {
        gameId: params.gameId,
        progress: 'Describe the current situation and setting'
      }
    };
  }
  
  const responseText = this.formatToolResponse(
    'getGame',
    'success',
    `Retrieved game state for: ${result.game.state.title}`,
    {
      gameId: params.gameId,
      title: result.game.state.title,
      keyState: [
        `Characters: ${result.game.state.characters?.length || 0}`,
        `Location: ${result.game.state.world?.location || 'Unknown'}`,
        `Story: ${result.game.state.story?.progress || 'Not started'}`,
        `Last updated: ${result.game.updatedAt.toISOString()}`
      ]
    },
    `Retrieved complete game state for inspection. Current status: ${hasOptions ? 'Awaiting player choice' : 'Ready for progression'}`,
    nextStep,
    'Inspection mode - use retrieved state to determine next action',
    [
      'This is a read-only operation',
      `Story progress: ${hasStory ? 'Active' : 'Not started'}`,
      `Player options: ${hasOptions ? 'Presented' : 'None'}`,
      `Player selection: ${hasSelection ? 'Made' : 'Pending'}`
    ]
  );
  
  return {
    content: [{ type: 'text', text: responseText }],
  };
}
```

### 5. Modify handleProgressStory

**File**: `src/index.ts`
**Lines**: 287-300

```typescript
private async handleProgressStory(params: ProgressStoryParams): Promise<CallToolResult> {
  if (!params.gameId || typeof params.progress !== 'string') {
    throw new Error('gameId and progress parameters are required');
  }
  const result = this.gameManager.progressStory(params.gameId, params.progress);
  
  const deltas = result.game.state._pendingDeltas || [];
  
  const responseText = this.formatToolResponse(
    'progressStory',
    'success',
    `Story advanced: "${params.progress.substring(0, 60)}${params.progress.length > 60 ? '...' : ''}"`,
    {
      gameId: params.gameId,
      title: result.game.state.title,
      keyState: [
        `Chapter: ${result.game.state.story?.chapter || 'N/A'}`,
        `Location: ${result.game.state.world?.location || 'Unknown'}`,
        `Pending deltas: ${deltas.length}`
      ]
    },
    `Narrative advanced. Current situation: "${params.progress}"`,
    {
      tool: 'promptUserActions',
      reason: 'Present player with choices to respond to this situation',
      params: {
        gameId: params.gameId,
        options: [
          'Create 2-4 meaningful options that:',
          '- React to the current situation',
          '- Have different potential consequences',
          '- Align with character abilities and game state'
        ]
      }
    },
    'Step 2/5: createGame ‚Üí [progressStory] ‚Üí promptUserActions ‚Üí selectAction ‚Üí updateGame',
    [
      'Players need choices to interact with this situation',
      `${deltas.length} pending change(s) will be displayed in the next UI`,
      'Ensure options are contextually relevant to the story progress'
    ]
  );
  
  return {
    content: [{ type: 'text', text: responseText }],
  };
}
```

### 6. Modify handlePromptUserActions

**File**: `src/index.ts`
**Lines**: 302-344

**Special Case:** Still returns UI resource, but adds clear wait-state message

```typescript
private async handlePromptUserActions(params: PromptUserActionsParams): Promise<CallToolResult> {
  if (!params.gameId || !Array.isArray(params.options)) {
    throw new Error('gameId and options parameters are required');
  }
  if (params.options.length === 0) {
    throw new Error('options array cannot be empty');
  }
  const result = this.gameManager.promptUserActions(params.gameId, params.options);

  const uiHtml = this.generateGameUI(
    result.game.state.lastStoryProgress || 'The game begins...',
    params.options,
    params.gameId
  );

  this.gameManager.clearDeltas(params.gameId);

  const uiResource = {
    type: 'resource' as const,
    resource: {
      uri: `ui://rpg-game/${params.gameId}/actions`,
      mimeType: 'text/html',
      text: uiHtml,
      _meta: {
        title: 'RPG Game Actions',
        description: `Action selection for game ${params.gameId}`,
        preferredRenderContext: 'main',
      }
    }
  };
  
  const responseText = this.formatToolResponse(
    'promptUserActions',
    'success',
    `Presented ${params.options.length} choices to player`,
    {
      gameId: params.gameId,
      title: result.game.state.title,
      keyState: [
        `Situation: "${result.game.state.lastStoryProgress}"`,
        `Options presented: ${params.options.length}`,
        `Deltas displayed and cleared`
      ]
    },
    `Interactive UI generated with story progress and ${params.options.length} action buttons. Player can now make a selection.`,
    null, // No next step - waiting for user
    'Step 3/5: createGame ‚Üí progressStory ‚Üí [promptUserActions] ‚Üí WAITING FOR USER ‚Üí selectAction',
    [
      'PAUSED: Waiting for player to select an option via UI',
      'selectAction will be called automatically when player clicks a button',
      'Do not proceed until selectAction is invoked',
      `Options: ${params.options.map((o, i) => `[${i}] ${o}`).join(', ')}`
    ]
  );

  return {
    content: [
      uiResource,
      { type: 'text', text: responseText }
    ],
  };
}
```

### 7. Modify handleSelectAction

**File**: `src/index.ts`
**Lines**: 541-554

```typescript
private async handleSelectAction(params: SelectActionParams): Promise<CallToolResult> {
  if (!params.gameId || !params.selectedOption || params.selectedIndex === undefined) {
    throw new Error('gameId, selectedOption, and selectedIndex parameters are required');
  }
  const result = this.gameManager.selectAction(params.gameId, params.selectedOption, params.selectedIndex);
  
  const history = result.game.state._gameHistory || [];
  const recentChoices = history.slice(-3).map(h => h.selectedOption).join(' ‚Üí ');
  
  const responseText = this.formatToolResponse(
    'selectAction',
    'success',
    `Player selected: "${params.selectedOption}"`,
    {
      gameId: params.gameId,
      title: result.game.state.title,
      keyState: [
        `Situation: "${result.game.state.lastStoryProgress}"`,
        `Selected: [${params.selectedIndex}] "${params.selectedOption}"`,
        `History: ${history.length}/10 entries`
      ]
    },
    `Player's choice recorded. Selection: "${params.selectedOption}" in response to situation: "${result.game.state.lastStoryProgress}"`,
    {
      tool: 'updateGame',
      reason: `Apply the consequences of the selected action: "${params.selectedOption}"`,
      params: {
        gameId: params.gameId,
        fieldSelector: 'Determine which game state field to modify (e.g., characters[0].hp, world.location, inventory)',
        value: 'Calculate new value based on the action outcome and current game state'
      }
    },
    'Step 4/5: createGame ‚Üí progressStory ‚Üí promptUserActions ‚Üí [selectAction] ‚Üí updateGame ‚Üí progressStory',
    [
      'Determine consequences based on the selected action and current game state',
      'You may need to call updateGame multiple times for complex outcomes',
      'After all updates, call progressStory to narrate the results',
      `Recent player choices: ${recentChoices || 'This is the first choice'}`
    ]
  );
  
  return {
    content: [{ type: 'text', text: responseText }],
  };
}
```

### 8. Translate Delta Descriptions to English

**File**: `src/gameManager.ts`
**Lines**: 345-365 (generateDeltaDescription method)

**Change**: Replace Korean strings with English

```typescript
private generateDeltaDescription(field: string, initialValue: unknown, finalValue: unknown): string {
  const friendlyFieldName = this.getFriendlyFieldName(field);
  
  if (Array.isArray(finalValue) && Array.isArray(initialValue)) {
    const initialLength = initialValue.length;
    const finalLength = finalValue.length;
    if (finalLength > initialLength) {
      return `${friendlyFieldName}: ${finalLength - initialLength} item(s) added`;
    } else if (finalLength < initialLength) {
      return `${friendlyFieldName}: ${initialLength - finalLength} item(s) removed`;
    } else {
      return `${friendlyFieldName}: contents changed`;
    }
  } else if (typeof finalValue === 'number' && typeof initialValue === 'number') {
    const change = finalValue - initialValue;
    if (change > 0) {
      return `${friendlyFieldName}: increased by ${change} (${initialValue} ‚Üí ${finalValue})`;
    } else {
      return `${friendlyFieldName}: decreased by ${Math.abs(change)} (${initialValue} ‚Üí ${finalValue})`;
    }
  } else {
    return `${friendlyFieldName}: changed from ${JSON.stringify(initialValue)} to ${JSON.stringify(finalValue)}`;
  }
}
```

### 9. Translate Field Name Mappings to English

**File**: `src/gameManager.ts`
**Lines**: 368-381 (getFriendlyFieldName method)

**Change**: Replace Korean values with English

```typescript
private getFriendlyFieldName(field: string): string {
  const fieldMap: Record<string, string> = {
    'characters': 'Character',
    'world': 'World',
    'inventory': 'Inventory',
    'story': 'Story',
    'title': 'Title',
    'hp': 'HP',
    'mp': 'MP',
    'level': 'Level',
    'favorability': 'Favorability',
    'location': 'Location',
    'time': 'Time',
    'weather': 'Weather'
  };

  const parts = field.split(/[.\[\]]/);
  const mainField = parts[0];
  
  return fieldMap[mainField] || mainField;
}
```

---

## Reusable Related Code

### Key Interfaces (src/types.ts)

```typescript
// Lines 25-43: GameState interface
interface GameState {
  title: string;
  characters?: Character[];
  world?: WorldState;
  inventory?: InventoryItem[];
  story?: StoryState;
  lastStoryProgress?: string;
  gameHistory?: GameHistoryEntry[];
  selectedAction?: { option: string; index: number; timestamp: Date };
  _pendingDeltas?: DeltaInfo[];
  _lastPromptTime?: Date;
  [key: string]: any;
}

// Lines 1-10: GameHistoryEntry
interface GameHistoryEntry {
  situation: string;
  options: string[];
  selectedOption: string;
  selectedIndex: number;
  timestamp: Date;
}

// Lines 14-21: DeltaInfo
interface DeltaInfo {
  field: string;
  initialValue: any;
  finalValue: any;
  timestamp: Date;
  description: string;
}
```

### Game Flow from README.md

```
Line 39: createGame ‚Üí progressStory ‚Üí promptUserActions ‚Üí selectAction ‚Üí updateGame ‚Üí progressStory ‚Üí ...
```

### GameManager Methods (src/gameManager.ts)

- `createGame()` - Lines 18-35: Returns `GameResponse` with `nextActions: ['progressStory']`
- `updateGame()` - Lines 40-73: Returns `GameResponse` with `nextActions: ['progressStory']`
- `getGame()` - Lines 78-87: Returns `GameResponse` with `nextActions: []`
- `progressStory()` - Lines 116-135: Returns `GameResponse` with `nextActions: ['promptUserActions']`
- `promptUserActions()` - Lines 140-156: Returns `GameResponse` with `nextActions: []`
- `selectAction()` - Lines 89-114: Returns `GameResponse` with `nextActions: ['updateGame']`

---

## Implementation Notes

### Flexibility for Implementer

- The exact wording of messages can be adjusted for natural language flow
- Additional context can be added based on specific game state conditions
- Error responses should follow similar formatting pattern
- Consider edge cases (empty arrays, null values) in actual implementation

### Testing Approach

1. Test each handler individually with sample game state
2. Verify all required information present in response
3. Ensure gameId is always included
4. Check workflow guidance is accurate
5. Test with AI agent to verify comprehension

### Future Enhancements

- Consider adding emoji configuration (enable/disable)
- Add verbosity levels (concise vs. detailed)
- Create response templates for consistency
- Add response caching for repeated game states

---

## Validation Checklist

After implementation, verify each handler response includes:

- [ ] ‚úÖ/‚ùå Status indicator
- [ ] Game ID (always present)
- [ ] Game title
- [ ] Clear description of what occurred
- [ ] Next tool name (or wait state)
- [ ] Required parameters with values
- [ ] Workflow position indicator
- [ ] All text in English
- [ ] Context notes for complex scenarios

---

**End of Refactoring Plan**
