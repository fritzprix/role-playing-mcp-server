# RPG MCP Server UI Resource Integration 리팩토링 계획서

## 작업의 목적

RPG 게임 MCP 서버에서 사용자 액션 선택 과정을 개선하여, 텍스트 기반 응답에서 인터랙티브한 UI Resource 기반 응답으로 전환함으로써 사용자 경험을 향상시킵니다.

## 현재의 상태 / 문제점

### 현재 Tool Chaining 흐름

1. `createGame/updateGame` → `progressStory` → `promptUserActions` (종료)
2. `promptUserActions`는 단순히 선택지 배열만 반환
3. 사용자는 방금 일어난 스토리 내용과 선택지가 분리되어 맥락을 잃음

### 구체적인 문제

- **맥락 손실**: `progressStory`에서 설정한 스토리 진행 내용이 `promptUserActions`에서 접근 불가
- **비인터랙티브**: 선택지가 텍스트 배열로만 제공되어 클릭 가능한 UI 없음
- **Tool Chaining 단절**: `promptUserActions` 이후 사용자 선택을 처리할 도구 없음

### 현재 코드 상태 (2025-09-07 개선 후)

```typescript
// index.ts - 타입 개선 완료
private async handleCreateGame(params: CreateGameParams): Promise<CallToolResult> {
  const result = this.gameManager.createGame(params.initialStateInJson);
  return {
    content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
  };
}

// gameManager.ts - 타입 개선 완료
createGame(initialState: GameState): GameResponse {
  // ... 구현
}
```

## 추가 분석 과제

1. **MCP-UI Resource 반환 형식**: 현재 MCP SDK의 CallToolResult와 MCP-UI의 UIResource 통합 방식 확인
2. **UI Action 처리**: UI에서 발생한 action이 MCP Tool 호출로 변환되는 메커니즘 분석
3. **게임 상태 확장**: 스토리 맥락 저장을 위한 GameState 구조 개선 필요성 검토

## 변경 이후의 상태 / 해결 판정 기준

### 목표 상태

1. **간단한 UI Resource 추가**: `promptUserActions`에서 기존 텍스트 응답에 UI 리소스 하나만 추가
2. **맥락 기반 설명**: 현재 스토리 진행(progress)과 선택지들에 대한 자연어 묘사 유지  
3. **연속적인 Tool Chaining**: `selectAction` 도구 추가로 사용자 선택 → 게임 진행 연결

### 해결 판정 기준

- [x] 타입 개선 완료 (CallToolResult 사용, any 제거)
- [ ] `promptUserActions`에서 UI 리소스와 텍스트를 포함한 content 배열 반환
- [ ] `selectAction` 도구 추가 및 핸들러 구현
- [ ] `selectAction` → `updateGame` → `progressStory` 체인 정상 작동

## 수정이 필요한 코드 및 수정부분의 코드 스니핏

### 1. types.ts - SelectActionParams 인터페이스 추가

```typescript
// MCP-UI 통합을 위한 타입 추가
export interface SelectActionParams {
  gameId: string;
  selectedOption: string;
  selectedIndex: number;
}

// GameState는 이미 lastStoryProgress 필드 존재하므로 수정 불필요
```

### 2. gameManager.ts - selectAction 메서드 추가

```typescript
selectAction(gameId: string, selectedOption: string, selectedIndex: number): GameResponse {
  const game = this.games.get(gameId);
  if (!game) {
    throw new Error(`Game with id ${gameId} not found`);
  }

  // 선택된 액션을 게임 상태에 반영
  game.state.selectedAction = {
    option: selectedOption,
    index: selectedIndex,
    timestamp: new Date()
  };

  game.updatedAt = new Date();

  return {
    game,
    nextActions: ["updateGame"] // 다음 업데이트로 체인 연결
  };
}
```

### 3. index.ts - promptUserActions 응답에 UI 리소스 추가

```typescript
private async handlePromptUserActions(params: PromptUserActionsParams): Promise<CallToolResult> {
  if (!params.gameId || !Array.isArray(params.options)) {
    throw new Error('gameId and options parameters are required');
  }
  if (params.options.length === 0) {
    throw new Error('options array cannot be empty');
  }
  const result = this.gameManager.promptUserActions(params.gameId, params.options);

  // UI resource와 텍스트 응답을 함께 제공
  return {
    content: [
      {
        type: 'resource',
        resource: {
          uri: `ui://rpg-game/${params.gameId}/actions`,
          mimeType: 'application/vnd.mcp.ui+json',
          blob: JSON.stringify({
            type: 'action-selector',
            gameId: params.gameId,
            options: params.options,
            context: result.game.state.lastStoryProgress || '게임이 계속됩니다...'
          })
        }
      },
      {
        type: 'text',
        text: JSON.stringify(result, null, 2),
      },
    ],
  };
}
```

### 4. index.ts - selectAction 도구 등록 및 핸들러 추가

```typescript
// Tool 목록에 selectAction 추가
{
  name: "selectAction",
  description: "Process user's selected action from UI and continue game flow",
  inputSchema: {
    type: "object",
    properties: {
      gameId: { type: "string", description: "ID of the game" },
      selectedOption: { type: "string", description: "The option text user selected" },
      selectedIndex: { type: "number", description: "Index of selected option (0-based)" }
    },
    required: ["gameId", "selectedOption", "selectedIndex"]
  }
}

// Tool 처리 핸들러에 selectAction 케이스 추가
case 'selectAction':
  result = await this.handleSelectAction(toolArgs as unknown as SelectActionParams);
  break;

// handleSelectAction 메서드 추가
private async handleSelectAction(params: SelectActionParams): Promise<CallToolResult> {
  if (!params.gameId || !params.selectedOption || params.selectedIndex === undefined) {
    throw new Error('gameId, selectedOption, and selectedIndex parameters are required');
  }
  const result = this.gameManager.selectAction(params.gameId, params.selectedOption, params.selectedIndex);
  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify(result, null, 2),
      },
    ],
  };
}
```

## 작업 우선순위

1. **Phase 1 (완료)**: 타입 정의 개선 (`index.ts`, `gameManager.ts` - CallToolResult 사용)
2. **Phase 2**: `types.ts`에 SelectActionParams 추가
3. **Phase 3**: `gameManager.ts`에 selectAction 메서드 추가
4. **Phase 4**: `index.ts`에 selectAction 도구 등록 및 핸들러 추가
5. **Phase 5**: `promptUserActions` 응답에 UI 리소스 추가

## 현재 상태 (2025-09-07 15:00)

### 완료된 작업

- ✅ 모든 handle* 메서드 타입을 `Promise<CallToolResult>`로 변경
- ✅ MCP SDK 타입 (`CallToolResult`) 정확히 사용
- ✅ `any` 타입 제거 및 명확한 타입 지정
- ✅ 각 핸들러에서 직접 content 구성하여 반환

### 다음 단계

- [ ] `selectAction` 도구 추가
- [ ] `promptUserActions`에 UI 리소스 추가 (resource + text content)

## 리스크 및 고려사항

- **호환성**: MCP resource의 `blob` 필드 사용 (기존 `data` 필드와 다름)
- **상태 관리**: 게임 상태에 selectedAction 필드 추가로 인한 타입 확장 필요
- **에러 처리**: UI Action 실패 시 fallback 텍스트 응답 제공 필요
